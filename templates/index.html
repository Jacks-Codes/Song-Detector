<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SONG DETECTOR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', 'Courier New', monospace;
            background: #000;
            color: #fff;
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
            position: relative;
        }

        /* WebGL Canvas for Fragment Shaders */
        #glitch-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        /* Particle System Canvas */
        #particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* Fullscreen Mode */
        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            display: none;
            pointer-events: none;
        }

        .fullscreen-mode.active {
            display: block;
        }

        .fullscreen-content {
            position: absolute;
            bottom: 40px;
            left: 40px;
            text-align: left;
            pointer-events: none;
            z-index: 101;
        }

        .fullscreen-song-title {
            font-family: 'Share Tech Mono', monospace;
            font-weight: 700;
            font-size: 1.8vw;
            line-height: 1.4;
            margin-bottom: 0.5vw;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: color 0.3s ease, -webkit-text-stroke 0.3s ease;
            -webkit-text-stroke-width: 0.08em;
            -webkit-text-stroke-color: transparent;
            text-stroke-width: 0.08em;
            text-stroke-color: transparent;
        }

        .fullscreen-song-title.light-bg {
            color: #fff;
            -webkit-text-stroke-color: #000;
            text-stroke-color: #000;
        }

        .fullscreen-song-title.dark-bg {
            color: #000;
            -webkit-text-stroke-color: #fff;
            text-stroke-color: #fff;
        }

        .fullscreen-song-album {
            font-family: 'Share Tech Mono', monospace;
            font-weight: 600;
            font-size: 1.3vw;
            margin-bottom: 1vw;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            transition: color 0.3s ease, -webkit-text-stroke 0.3s ease;
            -webkit-text-stroke-width: 0.06em;
            -webkit-text-stroke-color: transparent;
            text-stroke-width: 0.06em;
            text-stroke-color: transparent;
        }

        .fullscreen-song-album.light-bg {
            color: #fff;
            -webkit-text-stroke-color: #000;
            text-stroke-color: #000;
        }

        .fullscreen-song-album.dark-bg {
            color: #000;
            -webkit-text-stroke-color: #fff;
            text-stroke-color: #fff;
        }

        .fullscreen-song-time {
            font-family: 'Share Tech Mono', monospace;
            font-weight: 600;
            font-size: 1.1vw;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            transition: color 0.3s ease, -webkit-text-stroke 0.3s ease;
            -webkit-text-stroke-width: 0.05em;
            -webkit-text-stroke-color: transparent;
            text-stroke-width: 0.05em;
            text-stroke-color: transparent;
        }

        .fullscreen-song-time.light-bg {
            color: #fff;
            -webkit-text-stroke-color: #000;
            text-stroke-color: #000;
        }

        .fullscreen-song-time.dark-bg {
            color: #000;
            -webkit-text-stroke-color: #fff;
            text-stroke-color: #fff;
        }

        /* Fullscreen Toggle Button */
        .fullscreen-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 200;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            color: #fff;
            padding: 10px 20px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 14px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
        }

        .fullscreen-toggle:hover {
            background: rgba(255, 0, 255, 0.3);
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        /* Hide other content in fullscreen */
        body.fullscreen-active .top-left-panel,
        body.fullscreen-active .stats-panel,
        body.fullscreen-active .main-content {
            display: none;
        }

        /* Layered background images */
        .layered-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            overflow: hidden;
        }

        .bg-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0.6;
        }

        .bg-layer-1 {
            top: 0;
            left: 0;
            animation: move-layer-1 80s infinite ease-in-out, glitch-split-1 16s infinite;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
        }

        .bg-layer-2 {
            top: 0;
            left: 0;
            animation: move-layer-2 100s infinite ease-in-out, glitch-split-2 20s infinite;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
            mix-blend-mode: screen;
        }

        .bg-layer-3 {
            top: 0;
            left: 0;
            animation: move-layer-3 120s infinite ease-in-out, glitch-split-3 24s infinite;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
            mix-blend-mode: multiply;
        }

        /* RGB channel split glitch effect */
        .bg-layer-1::before,
        .bg-layer-1::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: inherit;
            background-size: cover;
            background-position: center;
            opacity: 0.8;
        }

        .bg-layer-1::before {
            clip-path: polygon(0 0, 32% 2%, 30% 48%, 2% 50%, 0 52%, 28% 100%, 0 100%);
            animation: glitch-red 16s infinite;
            filter: contrast(1.5) brightness(1.2);
            transform-origin: 15% 50%;
        }

        .bg-layer-1::after {
            clip-path: polygon(72% 0, 100% 0, 100% 100%, 70% 98%, 72% 52%, 100% 50%, 98% 48%, 72% 2%);
            animation: glitch-blue 16s infinite;
            filter: contrast(1.3) brightness(0.9);
            transform-origin: 85% 50%;
        }

        .bg-layer-2::before,
        .bg-layer-2::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: inherit;
            background-size: cover;
            background-position: center;
            opacity: 0.7;
        }

        .bg-layer-2::before {
            clip-path: polygon(18% 0, 22% 2%, 52% 0, 50% 25%, 52% 50%, 50% 75%, 52% 100%, 20% 98%, 22% 100%);
            animation: glitch-green 20s infinite;
            filter: contrast(1.4) brightness(1.1);
            transform-origin: 35% 50%;
        }

        .bg-layer-2::after {
            clip-path: polygon(48% 0, 52% 2%, 82% 0, 80% 25%, 82% 50%, 80% 75%, 82% 100%, 50% 98%, 48% 100%);
            animation: glitch-red-2 20s infinite;
            filter: contrast(1.6) brightness(1.3);
            transform-origin: 65% 50%;
        }

        .bg-layer-3::before,
        .bg-layer-3::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: inherit;
            background-size: cover;
            background-position: center;
            opacity: 0.6;
        }

        .bg-layer-3::before {
            clip-path: polygon(8% 0, 12% 2%, 42% 0, 40% 30%, 42% 50%, 40% 70%, 42% 100%, 10% 98%, 8% 100%);
            animation: glitch-blue-2 24s infinite;
            filter: contrast(1.5) brightness(0.8);
            transform-origin: 25% 50%;
        }

        .bg-layer-3::after {
            clip-path: polygon(58% 0, 62% 2%, 92% 0, 90% 30%, 92% 50%, 90% 70%, 92% 100%, 60% 98%, 58% 100%);
            animation: glitch-green-2 24s infinite;
            filter: contrast(1.7) brightness(1.2);
            transform-origin: 75% 50%;
        }

        /* Enhanced RGB Split / Chromatic Aberration */
        .rgb-split-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        .rgb-channel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0.5;
        }

        .rgb-red {
            filter: blur(2px) contrast(1.5) brightness(1.3) saturate(1.4);
            animation: rgb-red-shift 20s infinite;
            mix-blend-mode: screen;
        }

        .rgb-green {
            filter: blur(1.5px) contrast(1.4) brightness(1.2) saturate(1.3);
            animation: rgb-green-shift 20s infinite;
            mix-blend-mode: screen;
        }

        .rgb-blue {
            filter: blur(2.5px) contrast(1.6) brightness(1.4) saturate(1.5);
            animation: rgb-blue-shift 20s infinite;
            mix-blend-mode: screen;
        }

        /* Scan Lines */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            animation: scanline-move 8s linear infinite;
            opacity: 0.6;
        }

        /* VHS Distortion */
        .vhs-distortion {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
            background: transparent;
            animation: vhs-jitter 0.1s infinite;
        }

        .vhs-distortion::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            animation: vhs-tracking 12s infinite;
        }

        .vhs-distortion::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(255, 0, 0, 0.05) 0px,
                rgba(255, 0, 0, 0.05) 1px,
                transparent 1px,
                transparent 3px
            );
            animation: vhs-horizontal-glitch 15s infinite;
        }

        /* Blocky Artifacts / Datamosh */
        .blocky-artifacts {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            opacity: 0.3;
        }

        .artifact-block {
            position: absolute;
            background: inherit;
            background-size: cover;
            mix-blend-mode: difference;
            animation: artifact-glitch 6s infinite;
        }

        .artifact-block-1 {
            width: 15%;
            height: 20%;
            top: 10%;
            left: 5%;
            clip-path: polygon(0 0, 100% 0, 95% 100%, 5% 100%);
            animation-delay: 0s;
        }

        .artifact-block-2 {
            width: 12%;
            height: 15%;
            top: 60%;
            right: 8%;
            clip-path: polygon(5% 0, 100% 0, 100% 100%, 0 100%);
            animation-delay: 2s;
        }

        .artifact-block-3 {
            width: 18%;
            height: 25%;
            bottom: 15%;
            left: 30%;
            clip-path: polygon(0 0, 100% 5%, 100% 100%, 0 95%);
            animation-delay: 4s;
        }

        @keyframes glitch-split-1 {
            0%, 100% { 
                transform: translate(0, 0) skew(0deg) scale(1);
                clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
            }
            15% { 
                transform: translate(-8px, 12px) skew(-2deg, 1deg) scale(1.05, 0.98);
                clip-path: polygon(0 0, 38% 2%, 40% 48%, 2% 50%, 0 52%, 42% 52%, 44% 98%, 0 100%, 100% 100%, 100% 0);
            }
            30% { 
                transform: translate(12px, -15px) skew(3deg, -2deg) scale(0.95, 1.08);
                clip-path: polygon(0 0, 100% 0, 98% 45%, 100% 50%, 98% 55%, 100% 100%, 0 100%, 2% 55%, 0 50%, 2% 45%);
            }
            50% { 
                transform: translate(0, 0) skew(0deg) scale(1.02, 0.96);
                clip-path: polygon(0 0, 35% 0, 37% 25%, 35% 50%, 37% 75%, 35% 100%, 0 100%, 65% 100%, 67% 75%, 65% 50%, 67% 25%, 65% 0, 100% 0, 100% 100%);
            }
            70% { 
                transform: translate(-15px, 8px) skew(2deg, -1deg) scale(0.98, 1.06);
                clip-path: polygon(0 0, 100% 0, 100% 30%, 98% 32%, 100% 35%, 98% 68%, 100% 70%, 100% 100%, 0 100%, 0 70%, 2% 68%, 0 35%, 2% 32%, 0 30%);
            }
            85% { 
                transform: translate(10px, -10px) skew(-1deg, 2deg) scale(1.04, 0.94);
                clip-path: polygon(0 0, 62% 0, 64% 20%, 62% 40%, 64% 60%, 62% 80%, 64% 100%, 0 100%, 100% 100%, 100% 0);
            }
        }

        @keyframes glitch-split-2 {
            0%, 100% { 
                transform: translate(0, 0) skew(0deg) scale(1);
            }
            20% { 
                transform: translate(25px, -20px) skew(-4deg, 3deg) scale(1.1, 0.9);
            }
            40% { 
                transform: translate(-20px, 25px) skew(4deg, -3deg) scale(0.9, 1.1);
            }
            60% { 
                transform: translate(15px, 18px) skew(-2deg, -2deg) scale(1.06, 0.94);
            }
            80% { 
                transform: translate(-18px, -15px) skew(2deg, 2deg) scale(0.94, 1.06);
            }
        }

        @keyframes glitch-split-3 {
            0%, 100% { 
                transform: translate(0, 0) skew(0deg) scale(1);
            }
            25% { 
                transform: translate(-30px, 0) skew(5deg, 0deg) scale(1.15, 0.85);
            }
            50% { 
                transform: translate(30px, 0) skew(-5deg, 0deg) scale(0.85, 1.15);
            }
            75% { 
                transform: translate(0, -25px) skew(0deg, 4deg) scale(1, 1.12);
            }
        }

        @keyframes glitch-red {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); }
            20% { transform: translate(-20px, 5px) skew(-3deg, 1deg) scale(1.08, 0.95); }
            40% { transform: translate(20px, -8px) skew(3deg, -1deg) scale(0.92, 1.1); }
            60% { transform: translate(-5px, -15px) skew(-1deg, 2deg) scale(1.05, 0.9); }
            80% { transform: translate(8px, 12px) skew(1deg, -2deg) scale(0.95, 1.08); }
        }

        @keyframes glitch-blue {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); }
            25% { transform: translate(25px, 10px) skew(4deg, -2deg) scale(1.12, 0.88); }
            50% { transform: translate(-25px, -10px) skew(-4deg, 2deg) scale(0.88, 1.12); }
            75% { transform: translate(10px, -20px) skew(2deg, 3deg) scale(1.06, 0.94); }
        }

        @keyframes glitch-green {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); }
            30% { transform: translate(-18px, 12px) skew(-2deg, -3deg) scale(0.9, 1.1); }
            60% { transform: translate(18px, -12px) skew(2deg, 3deg) scale(1.1, 0.9); }
        }

        @keyframes glitch-red-2 {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); }
            35% { transform: translate(28px, -5px) skew(5deg, -1deg) scale(1.15, 0.85); }
            70% { transform: translate(-28px, 5px) skew(-5deg, 1deg) scale(0.85, 1.15); }
        }

        @keyframes glitch-blue-2 {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); }
            28% { transform: translate(-22px, -12px) skew(-3deg, 4deg) scale(0.92, 1.08); }
            56% { transform: translate(22px, 12px) skew(3deg, -4deg) scale(1.08, 0.92); }
        }

        @keyframes glitch-green-2 {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); }
            45% { transform: translate(0, -20px) skew(0deg, 5deg) scale(1, 1.2); }
            90% { transform: translate(0, 20px) skew(0deg, -5deg) scale(1, 0.8); }
        }

        @keyframes move-layer-1 {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); transform-origin: 50% 50%; }
            25% { transform: translate(-15px, -40px) skew(-2deg, 1deg) scale(1.08, 0.94); transform-origin: 30% 20%; }
            50% { transform: translate(20px, 35px) skew(2deg, -1deg) scale(0.92, 1.06); transform-origin: 70% 80%; }
            75% { transform: translate(-10px, 25px) skew(-1deg, 2deg) scale(1.04, 0.96); transform-origin: 40% 60%; }
        }

        @keyframes move-layer-2 {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); transform-origin: 50% 50%; }
            30% { transform: translate(25px, 50px) skew(3deg, -2deg) scale(0.9, 1.12); transform-origin: 60% 70%; }
            60% { transform: translate(-30px, -45px) skew(-3deg, 2deg) scale(1.1, 0.88); transform-origin: 40% 30%; }
        }

        @keyframes move-layer-3 {
            0%, 100% { transform: translate(0, 0) skew(0deg) scale(1); transform-origin: 50% 50%; }
            20% { transform: translate(-20px, -30px) skew(-1deg, 3deg) scale(1.06, 0.92); transform-origin: 25% 25%; }
            40% { transform: translate(30px, 20px) skew(1deg, -3deg) scale(0.94, 1.08); transform-origin: 75% 75%; }
            60% { transform: translate(-15px, 40px) skew(-2deg, 1deg) scale(1.02, 0.98); transform-origin: 50% 80%; }
            80% { transform: translate(18px, -25px) skew(2deg, -1deg) scale(0.98, 1.02); transform-origin: 50% 20%; }
        }

        /* RGB Split Animations */
        @keyframes rgb-red-shift {
            0%, 100% { transform: translate(0, 0); filter: blur(2px) contrast(1.5) brightness(1.3) saturate(1.4) hue-rotate(0deg); }
            25% { transform: translate(-25px, 8px); filter: blur(3px) contrast(1.8) brightness(1.6) saturate(1.7) hue-rotate(8deg); }
            50% { transform: translate(22px, -12px); filter: blur(2.5px) contrast(1.7) brightness(1.5) saturate(1.6) hue-rotate(-6deg); }
            75% { transform: translate(-15px, 15px); filter: blur(2.8px) contrast(1.9) brightness(1.7) saturate(1.8) hue-rotate(4deg); }
        }

        @keyframes rgb-green-shift {
            0%, 100% { transform: translate(0, 0); filter: blur(1.5px) contrast(1.4) brightness(1.2) saturate(1.3) hue-rotate(0deg); }
            30% { transform: translate(18px, -8px); filter: blur(2px) contrast(1.6) brightness(1.4) saturate(1.5) hue-rotate(-4deg); }
            60% { transform: translate(-20px, 10px); filter: blur(1.8px) contrast(1.7) brightness(1.5) saturate(1.6) hue-rotate(7deg); }
        }

        @keyframes rgb-blue-shift {
            0%, 100% { transform: translate(0, 0); filter: blur(2.5px) contrast(1.6) brightness(1.4) saturate(1.5) hue-rotate(0deg); }
            20% { transform: translate(30px, 5px); filter: blur(3.5px) contrast(1.9) brightness(1.7) saturate(1.8) hue-rotate(-8deg); }
            40% { transform: translate(-18px, -15px); filter: blur(3px) contrast(1.8) brightness(1.6) saturate(1.7) hue-rotate(6deg); }
            60% { transform: translate(12px, 18px); filter: blur(3.2px) contrast(2.0) brightness(1.8) saturate(1.9) hue-rotate(-4deg); }
            80% { transform: translate(-22px, -8px); filter: blur(2.8px) contrast(1.7) brightness(1.5) saturate(1.6) hue-rotate(8deg); }
        }

        /* Scan Line Animations */
        @keyframes scanline-move {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* VHS Distortion Animations */
        @keyframes vhs-jitter {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            30% { transform: translateX(-0.5px); }
            40% { transform: translateX(0.5px); }
            50% { transform: translateX(-1px); }
            60% { transform: translateX(1px); }
            70% { transform: translateX(-0.5px); }
            80% { transform: translateX(0.5px); }
            90% { transform: translateX(0); }
        }

        @keyframes vhs-tracking {
            0%, 100% { transform: translateY(0) scaleY(1); opacity: 0.03; }
            25% { transform: translateY(-2px) scaleY(1.01); opacity: 0.05; }
            50% { transform: translateY(0) scaleY(0.99); opacity: 0.02; }
            75% { transform: translateY(2px) scaleY(1.01); opacity: 0.04; }
        }

        @keyframes vhs-horizontal-glitch {
            0%, 100% { transform: translateY(0); opacity: 0.05; }
            15% { transform: translateY(-3px); opacity: 0.08; }
            30% { transform: translateY(0); opacity: 0.03; }
            45% { transform: translateY(3px); opacity: 0.07; }
            60% { transform: translateY(0); opacity: 0.04; }
            75% { transform: translateY(-2px); opacity: 0.06; }
            90% { transform: translateY(0); opacity: 0.05; }
        }

        /* Blocky Artifact Animations */
        @keyframes artifact-glitch {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
            20% { transform: translate(15px, -10px) scale(1.1); opacity: 0.5; }
            40% { transform: translate(-12px, 8px) scale(0.9); opacity: 0.2; }
            60% { transform: translate(8px, 12px) scale(1.05); opacity: 0.4; }
            80% { transform: translate(-10px, -8px) scale(0.95); opacity: 0.35; }
        }

        .top-left-panel {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 100;
            max-width: 500px;
            pointer-events: none;
        }

        .now-playing-label {
            font-family: 'Share Tech Mono', monospace;
            font-size: 2.5em;
            text-transform: uppercase;
            letter-spacing: 8px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.5),
                2px 2px 4px rgba(0, 0, 0, 0.8);
            margin-bottom: 20px;
        }

        .status::before {
            content: '[●] ';
            color: #0f0;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 80px 20px 40px;
            position: relative;
            z-index: 10;
        }

        .songs-container {
            display: flex;
            flex-direction: column;
            gap: 25px;
            margin-top: 30px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            pointer-events: auto;
        }

        .song-item {
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            width: 100%;
            pointer-events: auto;
        }

        .song-item:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .song-item:first-child {
            border-width: 2px;
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Layered artwork on song cards */
        .song-artwork-container {
            width: 100%;
            height: 300px;
            position: relative;
            overflow: hidden;
        }

        .artwork-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0.85;
        }

        .artwork-layer-1 {
            mix-blend-mode: normal;
            animation: artwork-move-1 16s infinite ease-in-out;
            filter: brightness(1.1);
        }

        .artwork-layer-2 {
            mix-blend-mode: multiply;
            animation: artwork-move-2 20s infinite ease-in-out;
            filter: brightness(0.9) contrast(1.2);
            opacity: 0.7;
        }

        @keyframes artwork-move-1 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(0, -15px) scale(1.02); }
        }

        @keyframes artwork-move-2 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(0, 15px) scale(0.98); }
        }

        .song-artwork {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .no-artwork {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            color: rgba(255, 255, 255, 0.3);
            font-weight: 900;
            text-transform: uppercase;
        }

        .song-info {
            padding: 25px;
            position: relative;
            background: rgba(0, 0, 0, 0.6);
        }

        .song-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            font-weight: 700;
            text-transform: uppercase;
            margin-bottom: 10px;
            color: #fff;
            letter-spacing: 2px;
            line-height: 1.2;
        }

        .song-artist {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .song-album {
            font-size: 1em;
            font-weight: 400;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.7);
            font-style: italic;
        }

        .song-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            padding-top: 12px;
            margin-top: 12px;
        }

        .song-timestamp {
            font-size: 0.85em;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
        }

        .song-timestamp-relative {
            font-size: 0.9em;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 80px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.5);
        }

        .empty-state h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2em;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 20px;
            letter-spacing: 4px;
            color: #fff;
        }

        .empty-state p {
            font-size: 1em;
            color: rgba(255, 255, 255, 0.6);
        }

        .stats-bar {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            pointer-events: auto;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            font-weight: 900;
            color: #fff;
            display: block;
            margin-bottom: 3px;
        }

        .stat-label {
            font-size: 0.65em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.6);
        }

        .footer {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
            font-size: 0.7em;
            backdrop-filter: blur(10px);
            margin-top: 20px;
            pointer-events: auto;
        }

        .full-history-section {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            pointer-events: auto;
        }
        
        .full-history-section::-webkit-scrollbar {
            width: 14px;
        }
        
        .full-history-section::-webkit-scrollbar-track {
            background: #000;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: inset -1px 0 0 rgba(255, 255, 255, 0.1);
        }
        
        .full-history-section::-webkit-scrollbar-thumb {
            background: 
                repeating-linear-gradient(
                    90deg,
                    #000 0px,
                    #000 2px,
                    rgba(255, 255, 255, 0.03) 2px,
                    rgba(255, 255, 255, 0.03) 4px
                ),
                #000;
            border: 2px solid #fff;
            border-left: 3px solid #fff;
            border-right: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 
                inset 0 0 8px rgba(255, 255, 255, 0.15),
                0 0 2px rgba(255, 255, 255, 0.3);
        }
        
        .full-history-section::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #fff;
            border-left: 3px solid #fff;
            box-shadow: 
                inset 0 0 12px rgba(255, 255, 255, 0.25),
                0 0 4px rgba(255, 255, 255, 0.5);
        }
        
        .full-history-section::-webkit-scrollbar-thumb:active {
            background: rgba(255, 255, 255, 0.15);
            border-color: #fff;
            box-shadow: 
                inset 0 0 15px rgba(255, 255, 255, 0.4),
                0 0 6px rgba(255, 255, 255, 0.7);
        }
        
        .full-history-section::-webkit-scrollbar-corner {
            background: #000;
        }
        
        /* Firefox scrollbar styling */
        .full-history-section {
            scrollbar-width: auto;
            scrollbar-color: #fff #000;
        }

        .history-title {
            font-family: 'Share Tech Mono', monospace;
            font-weight: 700;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: #fff;
            opacity: 0.9;
        }

        .history-list {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.75em;
            line-height: 1.6;
            color: #fff;
        }

        .history-item {
            padding: 0.25em 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-song {
            font-weight: 600;
            flex: 1;
        }

        .history-artist {
            opacity: 0.7;
            margin-left: 0.5em;
            flex: 1;
        }

        .history-time {
            opacity: 0.5;
            font-size: 0.85em;
            margin-left: 1em;
            text-align: right;
            min-width: 120px;
        }

        .main-content {
            position: relative;
            z-index: 10;
        }

        @media (max-width: 768px) {
            .top-left-panel {
                max-width: calc(100% - 40px);
                left: 20px;
                top: 20px;
            }

            .now-playing-label {
                font-size: 1.8em;
            }

            .song-title {
                font-size: 1.2em;
            }

            .stat-value {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="layered-bg" id="layeredBackground">
        <div class="bg-layer bg-layer-1" id="bgLayer1"></div>
        <div class="bg-layer bg-layer-2" id="bgLayer2"></div>
        <div class="bg-layer bg-layer-3" id="bgLayer3"></div>
        
        <!-- Enhanced RGB Split / Chromatic Aberration -->
        <div class="rgb-split-overlay" id="rgbSplitOverlay">
            <div class="rgb-channel rgb-red" id="rgbRed"></div>
            <div class="rgb-channel rgb-green" id="rgbGreen"></div>
            <div class="rgb-channel rgb-blue" id="rgbBlue"></div>
        </div>
        
        <!-- Blocky Artifacts / Datamosh -->
        <div class="blocky-artifacts">
            <div class="artifact-block artifact-block-1"></div>
            <div class="artifact-block artifact-block-2"></div>
            <div class="artifact-block artifact-block-3"></div>
        </div>
    </div>
    
    <!-- Scan Lines -->
    <div class="scanlines"></div>
    
    <!-- VHS Distortion -->
    <div class="vhs-distortion"></div>
    
    <!-- WebGL Canvas for Fragment Shader Effects -->
    <canvas id="glitch-canvas"></canvas>
    
    <!-- Particle System Canvas -->
    <canvas id="particles-canvas"></canvas>
    
    <!-- Fullscreen Mode -->
    <div class="fullscreen-mode" id="fullscreenMode">
        <div class="fullscreen-content">
            <div class="fullscreen-song-title" id="fullscreenTitle">NO SONG PLAYING</div>
            <div class="fullscreen-song-album" id="fullscreenAlbum"></div>
            <div class="fullscreen-song-time" id="fullscreenTime"></div>
        </div>
    </div>
    
    <!-- Fullscreen Toggle Button -->
    <button class="fullscreen-toggle" id="fullscreenToggle">FULLSCREEN</button>
    
    <div class="top-left-panel">
        <div class="now-playing-label">NOW PLAYING</div>
        
        <div class="stats-bar" id="statsBar">
            <div class="stat-item">
                <span class="stat-value" id="totalSongs">0</span>
                <span class="stat-label">TOTAL SONGS</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="songsToday">0</span>
                <span class="stat-label">TODAY</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="lastDetected">--</span>
                <span class="stat-label">LAST DETECTED</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="statusIndicator">●</span>
                <span class="stat-label">STATUS</span>
            </div>
        </div>

        <div class="footer">
            <p><strong>SONG DETECTOR</strong> | RASPBERRY PI ZERO 2 | LAST UPDATE: <span id="lastUpdate"></span></p>
        </div>
        
        <!-- Full History Text List -->
        <div class="full-history-section">
            <div class="history-title">FULL HISTORY</div>
            <div class="history-list" id="fullHistoryList">
                <p>LOADING...</p>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <div class="songs-container" id="songsContainer">
            <!-- Songs will be dynamically loaded via JavaScript -->
            <div class="empty-state">
                <h2>LOADING...</h2>
                <p>WAITING FOR SONG DATA</p>
            </div>
            </div>
        </div>
    </div>

    <script>
        function updateLastUpdateTime() {
            const now = new Date();
            const timeElement = document.getElementById('lastUpdate');
            if (timeElement) {
                timeElement.textContent = now.toLocaleTimeString().toUpperCase();
            }
        }

        function formatRelativeTime(timestamp) {
            if (!timestamp) return 'JUST NOW';
            
            const now = new Date();
            const songTime = new Date(timestamp);
            const diffMs = now - songTime;
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffSecs < 60) return 'JUST NOW';
            if (diffMins < 60) return `${diffMins}M AGO`;
            if (diffHours < 24) return `${diffHours}H AGO`;
            if (diffDays < 7) return `${diffDays}D AGO`;
            return songTime.toLocaleDateString().toUpperCase();
        }

        function updateStats(songs) {
            const totalSongs = songs.length;
            document.getElementById('totalSongs').textContent = totalSongs;

            // Count songs from today
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const songsToday = songs.filter(song => {
                if (!song.timestamp) return false;
                const songDate = new Date(song.timestamp);
                return songDate >= today;
            }).length;
            document.getElementById('songsToday').textContent = songsToday;

            // Last detected time
            if (songs.length > 0 && songs[0].timestamp) {
                const lastTime = formatRelativeTime(songs[0].timestamp);
                document.getElementById('lastDetected').textContent = lastTime;
            } else {
                document.getElementById('lastDetected').textContent = '--';
            }

            // Status indicator
            const statusEl = document.getElementById('statusIndicator');
            if (songs.length > 0) {
                statusEl.textContent = '●';
                statusEl.style.color = '#0f0';
            } else {
                statusEl.textContent = '○';
                statusEl.style.color = '#666';
            }
        }

        function updateRelativeTimestamps(songs) {
            document.querySelectorAll('.song-timestamp-relative').forEach((el, index) => {
                if (songs[index] && songs[index].timestamp) {
                    el.textContent = formatRelativeTime(songs[index].timestamp);
                }
            });
        }

        function updateLayeredBackground(songs) {
            const layers = [
                document.getElementById('bgLayer1'),
                document.getElementById('bgLayer2'),
                document.getElementById('bgLayer3')
            ];

            const rgbChannels = [
                document.getElementById('rgbRed'),
                document.getElementById('rgbGreen'),
                document.getElementById('rgbBlue')
            ];

            const artifactBlocks = document.querySelectorAll('.artifact-block');

            if (songs && songs.length > 0 && songs[0] && songs[0].artwork) {
                // Use ONLY the most recent (currently playing) song's artwork for all background layers
                const currentArtwork = songs[0].artwork;
                layers.forEach(layer => {
                    layer.style.backgroundImage = `url(${currentArtwork})`;
                });
                
                // Update RGB split channels
                rgbChannels.forEach(channel => {
                    channel.style.backgroundImage = `url(${currentArtwork})`;
                });
                
                // Update blocky artifacts
                artifactBlocks.forEach(block => {
                    block.style.backgroundImage = `url(${currentArtwork})`;
                });
                
                // Update WebGL shader texture
                if (typeof updateGlitchTexture === 'function') {
                    updateGlitchTexture(currentArtwork);
                }
            } else {
                // Clear backgrounds if no songs or no artwork
                layers.forEach(layer => {
                    layer.style.backgroundImage = 'none';
                });
                rgbChannels.forEach(channel => {
                    channel.style.backgroundImage = 'none';
                });
                artifactBlocks.forEach(block => {
                    block.style.backgroundImage = 'none';
                });
                
                // Clear shader texture - use default white texture
                if (glitchMaterial && glitchMaterial.uniforms) {
                    // Keep default texture instead of null
                }
            }
        }

        function updateSongsList(songs) {
            const container = document.getElementById('songsContainer');
            
            // Check for new songs and trigger particle burst
            checkForNewSongs(songs);
            
            // Update fullscreen mode with latest song
            updateFullscreenMode(songs);
            
            if (songs.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h2>NO SONGS DETECTED</h2>
                        <p>PLAY MUSIC TO BEGIN IDENTIFICATION</p>
                    </div>
                `;
                updateLayeredBackground([]);
                return;
            }

            updateLayeredBackground(songs);

            container.innerHTML = songs.map((song, index) => {
                const timestamp = song.timestamp ? new Date(song.timestamp).toLocaleString().toUpperCase() : 'JUST NOW';
                const firstLetter = song.title ? song.title.charAt(0).toUpperCase() : '?';
                
                const artworkHtml = song.artwork 
                    ? `
                        <div class="artwork-layer artwork-layer-1" style="background-image: url('${escapeHtml(song.artwork)}');"></div>
                        <div class="artwork-layer artwork-layer-2" style="background-image: url('${escapeHtml(song.artwork)}');"></div>
                    `
                    : `<div class="no-artwork">${firstLetter}</div>`;
                
                return `
                    <div class="song-item">
                        <div class="song-artwork-container">
                            ${artworkHtml}
                        </div>
                        <div class="song-info">
                            <div class="song-title">${escapeHtml(song.title.toUpperCase())}</div>
                            <div class="song-artist">${escapeHtml(song.artist.toUpperCase())}</div>
                            <div class="song-album">${escapeHtml(song.album)}</div>
                            <div class="song-meta">
                                <div class="song-timestamp-relative" data-timestamp="${song.timestamp || ''}">${formatRelativeTime(song.timestamp)}</div>
                                <div class="song-timestamp">${timestamp}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function fetchSongs() {
            fetch('/api/songs')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    updateSongsList(data);
                    updateStats(data);
                    updateLastUpdateTime();
                    // Update relative timestamps every minute
                    setTimeout(() => updateRelativeTimestamps(data), 1000);
                })
                .catch(error => {
                    console.error('ERROR FETCHING SONGS:', error);
                    // Show error state if API is not available
                    const container = document.getElementById('songsContainer');
                    if (container && container.innerHTML.includes('LOADING')) {
                        container.innerHTML = `
                            <div class="empty-state">
                                <h2>CONNECTION ERROR</h2>
                                <p>UNABLE TO CONNECT TO SERVER</p>
                                <p style="font-size: 0.8em; margin-top: 1em; opacity: 0.7;">Make sure Flask server is running</p>
                            </div>
                        `;
                    }
                });
        }

        function fetchFullHistory() {
            fetch('/api/songs/all')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    updateFullHistoryList(data);
                })
                .catch(error => {
                    console.error('ERROR FETCHING FULL HISTORY:', error);
                    const historyList = document.getElementById('fullHistoryList');
                    if (historyList) {
                        historyList.innerHTML = '<p>ERROR LOADING HISTORY</p>';
                    }
                });
        }

        function updateFullHistoryList(songs) {
            const historyList = document.getElementById('fullHistoryList');
            if (!historyList) return;

            if (!songs || songs.length === 0) {
                historyList.innerHTML = '<p>NO HISTORY</p>';
                return;
            }

            historyList.innerHTML = songs.map(song => {
                const title = song.title || 'Unknown';
                const artist = song.artist || 'Unknown Artist';
                const timestamp = song.timestamp ? new Date(song.timestamp).toLocaleString() : 'Unknown time';
                
                return `
                    <div class="history-item">
                        <span class="history-song">${escapeHtml(title.toUpperCase())}</span>
                        <span class="history-artist">${escapeHtml(artist.toUpperCase())}</span>
                        <span class="history-time">${escapeHtml(timestamp)}</span>
                    </div>
                `;
            }).join('');
            
            // Prevent scroll from propagating to body when scrolling the history section
            const historySection = historyList.closest('.full-history-section');
            if (historySection) {
                // Remove any existing listeners to avoid duplicates
                const newHandler = (e) => {
                    const { scrollTop, scrollHeight, clientHeight } = historySection;
                    const isAtTop = scrollTop <= 1;
                    const isAtBottom = scrollTop + clientHeight >= scrollHeight - 1;
                    
                    // If we can scroll in this direction within the history section, stop propagation
                    if (!((e.deltaY < 0 && isAtTop) || (e.deltaY > 0 && isAtBottom))) {
                        e.stopPropagation();
                    }
                };
                
                // Remove old listener if it exists and add new one
                historySection.removeEventListener('wheel', historySection._scrollHandler);
                historySection._scrollHandler = newHandler;
                historySection.addEventListener('wheel', newHandler, { passive: false });
            }
        }

        updateLastUpdateTime();
        fetchSongs(); // Initial load
        fetchFullHistory(); // Initial load of full history
        setInterval(fetchSongs, 5000);
        setInterval(fetchFullHistory, 30000); // Update full history every 30 seconds
        
        setInterval(() => {
            // Update relative timestamps every 30 seconds
            const container = document.getElementById('songsContainer');
            if (container && !container.innerHTML.includes('LOADING') && !container.innerHTML.includes('CONNECTION ERROR')) {
                fetch('/api/songs')
                    .then(response => response.json())
                    .then(data => updateRelativeTimestamps(data))
                    .catch(() => {
                        // Ignore errors in timestamp updates
                    });
            }
        }, 30000);

        // Three.js Fragment Shader Glitch Effect
        let glitchScene, glitchCamera, glitchRenderer, glitchMaterial, glitchMesh;
        let currentTexture = null;

        // Grainy Snow/Static Effect
        let snowScene, snowCamera, snowRenderer, snowMaterial, snowMesh;
        let snowTime = 0;

        function initGlitchShader() {
            const canvas = document.getElementById('glitch-canvas');
            if (!canvas) {
                console.error('Canvas element not found');
                return;
            }
            
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Scene setup
            glitchScene = new THREE.Scene();
            glitchCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            glitchRenderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                alpha: true,
                antialias: false 
            });
            glitchRenderer.setSize(width, height);
            glitchRenderer.setPixelRatio(window.devicePixelRatio || 1);

            // Fragment shader with glitch effects
            const fragmentShader = `
                uniform sampler2D uTexture;
                uniform float uTime;
                uniform vec2 uResolution;
                uniform float uIntensity;
                
                varying vec2 vUv;

                // Noise function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                // 2D Noise
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }

                // RGB Channel Split
                vec3 rgbSplit(vec2 uv, float intensity) {
                    float offset = intensity * 0.02;
                    float r = texture2D(uTexture, uv + vec2(offset, 0.0)).r;
                    float g = texture2D(uTexture, uv).g;
                    float b = texture2D(uTexture, uv - vec2(offset, 0.0)).b;
                    return vec3(r, g, b);
                }

                // Digital Glitch
                vec3 digitalGlitch(vec2 uv) {
                    float glitchTime = uTime * 2.0;
                    float glitchNoise = noise(vec2(glitchTime * 0.5, uv.y * 10.0));
                    
                    if (glitchNoise > 0.7) {
                        float offset = (glitchNoise - 0.7) * 0.1;
                        uv.x += offset * sin(glitchTime * 10.0);
                    }
                    
                    return texture2D(uTexture, uv).rgb;
                }

                // Scanline effect
                float scanlines(vec2 uv) {
                    return sin(uv.y * uResolution.y * 0.7 + uTime * 2.0) * 0.5 + 0.5;
                }

                // Chromatic aberration
                vec3 chromaticAberration(vec2 uv, float intensity) {
                    vec2 offset = vec2(intensity * 0.015, 0.0);
                    float r = texture2D(uTexture, uv + offset).r;
                    float g = texture2D(uTexture, uv).g;
                    float b = texture2D(uTexture, uv - offset).b;
                    return vec3(r, g, b);
                }

                // Pixel sorting effect
                vec3 pixelSort(vec2 uv) {
                    float sortNoise = noise(vec2(floor(uv.y * 50.0), uTime * 0.5));
                    if (sortNoise > 0.6) {
                        float offset = (sortNoise - 0.6) * 0.1;
                        uv.x += offset * sin(uTime * 5.0);
                    }
                    return texture2D(uTexture, uv).rgb;
                }

                void main() {
                    vec2 uv = vUv;
                    
                    // Base color with RGB split
                    vec3 color = rgbSplit(uv, uIntensity);
                    
                    // Digital glitch
                    color = mix(color, digitalGlitch(uv), 0.3);
                    
                    // Chromatic aberration
                    color = mix(color, chromaticAberration(uv, uIntensity), 0.4);
                    
                    // Pixel sorting
                    color = mix(color, pixelSort(uv), 0.2);
                    
                    // Scanlines
                    float scan = scanlines(uv);
                    color *= mix(0.9, 1.0, scan);
                    
                    // Noise overlay
                    float n = noise(uv * 200.0 + uTime);
                    color += vec3(n * 0.05);
                    
                    // VHS-style color shift
                    float shift = sin(uTime * 3.0 + uv.y * 10.0) * 0.02;
                    color.r = texture2D(uTexture, uv + vec2(shift, 0.0)).r;
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            // Create a default white texture
            const defaultTexture = new THREE.DataTexture(
                new Uint8Array([255, 255, 255, 255]),
                1,
                1,
                THREE.RGBAFormat
            );
            defaultTexture.needsUpdate = true;

            // Create material
            glitchMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: defaultTexture },
                    uTime: { value: 0 },
                    uResolution: { value: new THREE.Vector2(width, height) },
                    uIntensity: { value: 1.0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });

            // Create plane
            const geometry = new THREE.PlaneGeometry(2, 2);
            glitchMesh = new THREE.Mesh(geometry, glitchMaterial);
            glitchScene.add(glitchMesh);

            // Handle resize
            window.addEventListener('resize', () => {
                const w = window.innerWidth;
                const h = window.innerHeight;
                glitchRenderer.setSize(w, h);
                glitchMaterial.uniforms.uResolution.value.set(w, h);
            });

            // Start animation loop
            animateGlitch();
        }

        function updateGlitchTexture(imageUrl) {
            if (!glitchMaterial) {
                console.log('Glitch material not initialized yet');
                return;
            }

            const loader = new THREE.TextureLoader();
            loader.crossOrigin = 'anonymous'; // Handle CORS
            
            loader.load(
                imageUrl,
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    
                    if (currentTexture) {
                        currentTexture.dispose();
                    }
                    
                    currentTexture = texture;
                    glitchMaterial.uniforms.uTexture.value = texture;
                    console.log('Texture loaded successfully:', imageUrl);
                },
                undefined,
                (error) => {
                    console.error('Error loading texture:', error);
                    // Fallback: create a colored texture
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(0, 0, 512, 512);
                    const fallbackTexture = new THREE.CanvasTexture(canvas);
                    glitchMaterial.uniforms.uTexture.value = fallbackTexture;
                }
            );
        }

        function animateGlitch() {
            requestAnimationFrame(animateGlitch);
            
            if (glitchMaterial) {
                glitchMaterial.uniforms.uTime.value += 0.016; // ~60fps
                
                // Vary intensity
                const intensity = 1.0 + Math.sin(glitchMaterial.uniforms.uTime.value * 0.5) * 0.3;
                glitchMaterial.uniforms.uIntensity.value = intensity;
            }
            
            if (glitchRenderer && glitchScene && glitchCamera) {
                glitchRenderer.render(glitchScene, glitchCamera);
            }
        }

        // Initialize when page loads
        if (typeof THREE !== 'undefined') {
            setTimeout(() => {
                initGlitchShader();
                initParticleSystem();
            }, 100);
        } else {
            console.error('Three.js not loaded');
        }

        function initParticleSystem() {
            const canvas = document.getElementById('particles-canvas');
            if (!canvas) {
                console.error('Particles canvas not found');
                return;
            }

            const width = window.innerWidth;
            const height = window.innerHeight;

            // Scene setup
            snowScene = new THREE.Scene();
            snowCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            snowRenderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: false
            });
            snowRenderer.setSize(width, height);
            snowRenderer.setPixelRatio(window.devicePixelRatio || 1);

            // Fragment shader for grainy snow effect
            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uResolution;
                uniform float uIntensity;
                uniform vec2 uMouse;
                
                varying vec2 vUv;

                // Random function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                // Noise function
                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                }

                // Layered noise for depth
                float fbm(vec2 st) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for (int i = 0; i < 4; i++) {
                        value += amplitude * noise(st);
                        st *= 2.0;
                        amplitude *= 0.5;
                    }
                    return value;
                }

                void main() {
                    vec2 uv = vUv;
                    
                    // Calculate mouse influence (distance and direction from mouse)
                    vec2 mouseUv = uMouse / uResolution;
                    vec2 toMouse = mouseUv - uv;
                    float mouseDist = length(toMouse);
                    float mouseInfluence = 1.0 / (1.0 + mouseDist * 3.0); // Stronger near mouse
                    
                    // Create flowing/swirling motion that reacts to mouse
                    vec2 flow = vec2(
                        sin(uTime * 0.3 + uv.y * 3.0) * 0.1,
                        cos(uTime * 0.4 + uv.x * 2.0) * 0.1
                    );
                    
                    // Add mouse-reactive swirling
                    vec2 mouseSwirl = normalize(toMouse) * mouseInfluence * 0.3;
                    flow += mouseSwirl;
                    
                    // Add swooshy movement
                    vec2 swoosh = vec2(
                        sin(uTime * 0.5 + uv.y * 5.0) * 0.05,
                        cos(uTime * 0.6 + uv.x * 4.0) * 0.05
                    );
                    
                    // Add mouse pull effect
                    vec2 mousePull = toMouse * mouseInfluence * 0.2;
                    
                    vec2 distortedUv = uv + flow + swoosh + mousePull;
                    
                    // Create grainy snow texture
                    float grain = random(floor(distortedUv * uResolution * 2.0) + uTime * 10.0);
                    float noiseLayer = fbm(distortedUv * 8.0 + uTime * 0.2);
                    
                    // Combine grain and noise, intensify near mouse
                    float snow = mix(grain, noiseLayer, 0.3);
                    snow *= (1.0 + mouseInfluence * 0.5); // More intense near mouse
                    snow *= (0.3 + uIntensity * 0.4);
                    
                    // Create color variations that react to mouse position
                    // Use mouse position to shift colors
                    float mouseX = mouseUv.x;
                    float mouseY = mouseUv.y;
                    
                    // Color shifts based on mouse position
                    float r = snow;
                    float g = random(floor(distortedUv * uResolution * 1.5) + uTime * 8.0 + 100.0) * 0.1 + snow * 0.9;
                    float b = random(floor(distortedUv * uResolution * 1.8) + uTime * 12.0 + 200.0) * 0.1 + snow * 0.9;
                    
                    // Add mouse-reactive color tints
                    r += sin(uTime * 0.7) * 0.05 + mouseX * 0.1 * mouseInfluence;
                    g += cos(uTime * 0.8) * 0.05 + mouseY * 0.1 * mouseInfluence;
                    b += sin(uTime * 0.9) * 0.05 + (1.0 - mouseX) * 0.1 * mouseInfluence;
                    
                    // Add RGB split effect near mouse
                    float splitAmount = mouseInfluence * 0.02;
                    vec3 color = vec3(
                        r + splitAmount * sin(mouseDist * 10.0),
                        g,
                        b - splitAmount * cos(mouseDist * 10.0)
                    );
                    
                    // Increase intensity near mouse
                    float alpha = snow * (0.6 + mouseInfluence * 0.3);
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            // Create material
            snowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uResolution: { value: new THREE.Vector2(width, height) },
                    uIntensity: { value: 1.0 },
                    uMouse: { value: new THREE.Vector2(width / 2, height / 2) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            // Create plane
            const geometry = new THREE.PlaneGeometry(2, 2);
            snowMesh = new THREE.Mesh(geometry, snowMaterial);
            snowScene.add(snowMesh);

            // Handle resize
            window.addEventListener('resize', () => {
                const w = window.innerWidth;
                const h = window.innerHeight;
                snowRenderer.setSize(w, h);
                snowMaterial.uniforms.uResolution.value.set(w, h);
            });

            // Track mouse position
            let mouseX = width / 2;
            let mouseY = height / 2;
            
            window.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                if (snowMaterial) {
                    snowMaterial.uniforms.uMouse.value.set(mouseX, height - mouseY); // Flip Y for WebGL
                }
            });
            
            // Handle touch for mobile
            window.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                    if (snowMaterial) {
                        snowMaterial.uniforms.uMouse.value.set(mouseX, height - mouseY);
                    }
                }
            }, { passive: true });

            // Start animation
            animateParticles();
        }

        function animateParticles() {
            requestAnimationFrame(animateParticles);
            
            if (snowMaterial) {
                snowTime += 0.016;
                snowMaterial.uniforms.uTime.value = snowTime;
                
                // Vary intensity slightly
                const intensity = 1.0 + Math.sin(snowTime * 0.3) * 0.2;
                snowMaterial.uniforms.uIntensity.value = intensity;
            }
            
            if (snowRenderer && snowScene && snowCamera) {
                snowRenderer.render(snowScene, snowCamera);
            }
        }

        function triggerParticleBurst(intensity = 1.0) {
            // Increase intensity temporarily for audio reaction
            if (snowMaterial) {
                const originalIntensity = snowMaterial.uniforms.uIntensity.value;
                snowMaterial.uniforms.uIntensity.value = 1.5 + intensity * 0.5;
                setTimeout(() => {
                    if (snowMaterial) {
                        snowMaterial.uniforms.uIntensity.value = originalIntensity;
                    }
                }, 500);
            }
        }

        // Fullscreen Mode
        let isFullscreen = false;
        let currentFullscreenSong = null;
        let colorCheckInterval = null;

        // Calculate luminance (brightness) of a color
        function getLuminance(r, g, b) {
            // Relative luminance formula
            const [rs, gs, bs] = [r, g, b].map(val => {
                val = val / 255;
                return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
            });
            return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
        }

        // Update text colors based on background
        function updateFullscreenTextColors() {
            if (!isFullscreen) return;
            
            const fullscreenContent = document.querySelector('.fullscreen-content');
            if (!fullscreenContent) return;
            
            const rect = fullscreenContent.getBoundingClientRect();
            // Sample from multiple points around the text area for better accuracy
            const samplePoints = [
                { x: rect.left + rect.width * 0.2, y: rect.top + rect.height * 0.3 },
                { x: rect.left + rect.width * 0.5, y: rect.top + rect.height * 0.5 },
                { x: rect.left + rect.width * 0.8, y: rect.top + rect.height * 0.7 }
            ];
            
            let totalLuminance = 0;
            let samples = 0;
            
            // Try to read from WebGL canvas
            const glitchCanvas = document.getElementById('glitch-canvas');
            if (glitchCanvas) {
                try {
                    const gl = glitchCanvas.getContext('webgl') || glitchCanvas.getContext('webgl2');
                    if (gl) {
                        const pixel = new Uint8Array(4);
                        for (const point of samplePoints) {
                            try {
                                // WebGL coordinates: y is flipped
                                const x = Math.floor(point.x);
                                const y = Math.floor(glitchCanvas.height - point.y);
                                if (x >= 0 && x < glitchCanvas.width && y >= 0 && y < glitchCanvas.height) {
                                    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
                                    const luminance = getLuminance(pixel[0], pixel[1], pixel[2]);
                                    totalLuminance += luminance;
                                    samples++;
                                }
                            } catch (e) {
                                // Skip this point
                            }
                        }
                    }
                } catch (e) {
                    // WebGL read failed
                }
            }
            
            // Fallback: sample from background layers using getComputedStyle
            if (samples === 0) {
                const bgLayer1 = document.getElementById('bgLayer1');
                if (bgLayer1) {
                    const bgImage = window.getComputedStyle(bgLayer1).backgroundImage;
                    // If there's a background image, assume it might be light or dark
                    // Use a heuristic: check if the layer has high opacity/visibility
                    const opacity = parseFloat(window.getComputedStyle(bgLayer1).opacity) || 0;
                    // If background is visible, assume it could be either - use middle threshold
                    totalLuminance = opacity > 0.5 ? 0.4 : 0.2;
                    samples = 1;
                } else {
                    // Default to dark
                    totalLuminance = 0.2;
                    samples = 1;
                }
            }
            
            const avgLuminance = samples > 0 ? totalLuminance / samples : 0.3;
            
            // Use light text with black outline for light backgrounds
            // Use dark text with white outline for dark backgrounds
            // Threshold: 0.5 (0 = black, 1 = white)
            const isLightBg = avgLuminance > 0.5;
            const bgClass = isLightBg ? 'light-bg' : 'dark-bg';
            
            const fullscreenTitle = document.getElementById('fullscreenTitle');
            const fullscreenAlbum = document.getElementById('fullscreenAlbum');
            const fullscreenTime = document.getElementById('fullscreenTime');
            
            if (fullscreenTitle) {
                fullscreenTitle.classList.remove('light-bg', 'dark-bg');
                fullscreenTitle.classList.add(bgClass);
            }
            if (fullscreenAlbum) {
                fullscreenAlbum.classList.remove('light-bg', 'dark-bg');
                fullscreenAlbum.classList.add(bgClass);
            }
            if (fullscreenTime) {
                fullscreenTime.classList.remove('light-bg', 'dark-bg');
                fullscreenTime.classList.add(bgClass);
            }
        }

        function updateFullscreenMode(songs) {
            const fullscreenMode = document.getElementById('fullscreenMode');
            const fullscreenTitle = document.getElementById('fullscreenTitle');
            const fullscreenAlbum = document.getElementById('fullscreenAlbum');
            const fullscreenTime = document.getElementById('fullscreenTime');

            if (!fullscreenMode || !fullscreenTitle || !fullscreenAlbum || !fullscreenTime) return;

            if (songs && songs.length > 0) {
                const latestSong = songs[0]; // Most recent song
                currentFullscreenSong = latestSong;
                
                fullscreenTitle.textContent = latestSong.title ? latestSong.title.toUpperCase() : 'UNKNOWN SONG';
                fullscreenAlbum.textContent = latestSong.album ? latestSong.album.toUpperCase() : '';
                fullscreenTime.textContent = formatRelativeTime(latestSong.timestamp);
                
                // Update colors after a short delay to ensure background is rendered
                if (isFullscreen) {
                    setTimeout(updateFullscreenTextColors, 100);
                }
            } else {
                fullscreenTitle.textContent = 'NO SONG PLAYING';
                fullscreenAlbum.textContent = '';
                fullscreenTime.textContent = '';
            }
        }

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            const fullscreenMode = document.getElementById('fullscreenMode');
            const toggleButton = document.getElementById('fullscreenToggle');
            
            if (fullscreenMode) {
                if (isFullscreen) {
                    fullscreenMode.classList.add('active');
                    document.body.classList.add('fullscreen-active');
                    if (toggleButton) toggleButton.textContent = 'EXIT FULLSCREEN';
                    
                    // Start color checking interval
                    colorCheckInterval = setInterval(updateFullscreenTextColors, 200);
                    
                    // Initial color update after a delay
                    setTimeout(updateFullscreenTextColors, 300);
                    
                    // Request fullscreen API if available
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.log('Fullscreen request failed:', err);
                        });
                    }
                } else {
                    fullscreenMode.classList.remove('active');
                    document.body.classList.remove('fullscreen-active');
                    if (toggleButton) toggleButton.textContent = 'FULLSCREEN';
                    
                    // Stop color checking
                    if (colorCheckInterval) {
                        clearInterval(colorCheckInterval);
                        colorCheckInterval = null;
                    }
                    
                    // Exit fullscreen if in it
                    if (document.exitFullscreen) {
                        document.exitFullscreen().catch(err => {
                            console.log('Exit fullscreen failed:', err);
                        });
                    }
                }
            }
        }

        // Initialize fullscreen toggle
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        if (fullscreenToggle) {
            fullscreenToggle.addEventListener('click', toggleFullscreen);
        }

        // Handle fullscreen API events
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && isFullscreen) {
                // User exited fullscreen via browser controls
                isFullscreen = false;
                const fullscreenMode = document.getElementById('fullscreenMode');
                const toggleButton = document.getElementById('fullscreenToggle');
                if (fullscreenMode) fullscreenMode.classList.remove('active');
                document.body.classList.remove('fullscreen-active');
                if (toggleButton) toggleButton.textContent = 'FULLSCREEN';
                
                // Stop color checking
                if (colorCheckInterval) {
                    clearInterval(colorCheckInterval);
                    colorCheckInterval = null;
                }
            }
        });

        // Update fullscreen time every second when in fullscreen
        setInterval(() => {
            if (isFullscreen && currentFullscreenSong) {
                const fullscreenTime = document.getElementById('fullscreenTime');
                if (fullscreenTime) {
                    fullscreenTime.textContent = formatRelativeTime(currentFullscreenSong.timestamp);
                }
            }
        }, 1000);

        // Track song count to detect new songs
        let previousSongCount = 0;
        let previousSongIds = new Set();
        
        function checkForNewSongs(songs) {
            if (!songs || songs.length === 0) {
                previousSongCount = 0;
                previousSongIds.clear();
                return;
            }

            const currentCount = songs.length;
            const currentSongIds = new Set(songs.map(s => `${s.title}-${s.artist}-${s.timestamp}`));
            
            // Check if we have new songs (not just count change, but actual new songs)
            const newSongs = songs.filter(s => {
                const id = `${s.title}-${s.artist}-${s.timestamp}`;
                return !previousSongIds.has(id);
            });

            if (newSongs.length > 0 && previousSongCount > 0) {
                // New song(s) detected! Trigger snow intensity boost
                newSongs.forEach((song, index) => {
                    setTimeout(() => {
                        const intensity = 1.0 + Math.random() * 0.8;
                        triggerParticleBurst(intensity);
                    }, index * 100);
                });
            }
            
            previousSongCount = currentCount;
            previousSongIds = currentSongIds;
        }
    </script>
</body>
</html>
